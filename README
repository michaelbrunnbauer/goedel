
Definition of a primitive recursive function for validating proofs using a 
first order logic sequent calculus and ASCII-based Gödelization.

See http://www.brunni.de/goedel/definitions.txt for the complete printed 
definition generated by printdefinitions.py.

The sequent calculus and the proof examples are from the book "Einführung 
in die mathematische Logik" by Hans Hermes, published by B.G. Teubner 
Stuttgart 1991.

Variables, terms, propositions, formulae, sequences of formulae and proofs
are certain ASCII-strings interpreted as the numbers corresponding to their
bitstream.

Definitions:

namelc: Names for variables and functions are lower case strings consisting of 
a-z,0-9 and _ starting with a-z.

nameuc: Names for predicates are upper case strings consisting of
A-Z,0-9 and _ starting with A-Z.

The following definitions use BNF grammar:

termlist:
 term
 termlist , term

term:
 namelc
 namelc ( termlist )

proposition:
 nameuc ( termlist )

equation:
 term = term

formula:
 proposition
 equation
 ~ formula
 ( formula & formula )
 ! namelc : formula

(proposition,equation,negation,conjunction,generalization)

The usual definitions of the terms "variable x is free in formula f" and
"formula b is a substitution of term t for variable x in formula a" apply
(see functions_freevariable.py and functions_subst.py for details).

A sequence of formulae is a concatenation of formulae delimited by ; and
ending with ;. The last formula in a sequence is meant to be implied by the
preceding ones.

A proof is a concatenation of sequences of formulae delimited by \n and
ending with \n. A valid proof is a proof where every line can be generated by
application of a rule of the calculus on zero, one or two of the preceding 
lines.

The sequent calculus has the following rules. A and B are formulae, t is a
term, x is a variable, ... and --- are sequences of zero or more formulae.

1) A formula implies itself:

 A A

2) Introduction of conjunction

 ... A
 --- B
 ... --- (A&B)

3) Removal of conjunction1

 ... (A&B)
 ... A

4) Removal of conjunction2

 ... (A&B)
 ... B

5) Exhaustion

 ... A B
 --- ~A B
 ... --- B

6) Ex contradictione quodlibet

 ... A
 --- ~A
 ... --- B

7) Removal of generalization

 ... !x:A
 ... A

8) Introduction of generalization

 ... A
 ... !x:A (if x is not free in ...)

9) Substitution

 ... A
 --- B (if ... B is a substitution of t for x in ... A)

10) Tautological equation

 t=t

11) Substitution with assertion of identity

 ... A
 ... x=t B (if B is a substitution of t for x in A)

The sequences ..., --- or ... --- in the resulting sequence only have to
contain the same formulae as ..., --- or ... ---. It is allowed to permutate
and to introduce or remove repetitions. An additional rule allows to permutate
to get the required order for a rule:

12) Permutation

 ... A
 --- A (Where --- contains the same formulae as ...)

The primitive recursive definitions use the symbols 0, the successor function
succ(), the identity = and the numbers 1-255.

There are four types of functions (see functions.py):

-Basic functions defined by an expression

-Primitive recursive functions defined by the value for 0 and the value for
 n+1 based on the value for n

-Argmin-functions returning the smallest number within a range 0-max for
 which a function does not return 0 - otherwise 0. These are defined using 
 primitive recursive functions.

-"Recursive functions" returning 0 or 1 defined by the value for 0 and the 
 value for some number using values for smaller numbers. These are defined 
 using primitive recursive functions.

All definitions use powers to 2 to code and extract information instead of
prime numbers.

Use printdefinitions.py to print all definitions.

Use checkproof.py <file> to check a proof in ASCII-file <file> for vadility.

Use testsuite.py to run a testsuite.
